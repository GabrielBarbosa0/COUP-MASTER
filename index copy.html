<!doctype html>
<html lang="pt-BR">

<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Coup Master - Protótipo</title>
  <link rel="shortcut icon" href="img/coup.png" type="image/x-icon">

  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Cinzel:wght@400..900&display=swap" rel="stylesheet">

  <link rel="stylesheet"
    href="https://fonts.googleapis.com/css2?family=Material+Symbols+Outlined:opsz,wght,FILL,GRAD@20..48,100..700,0..1,-50..200&icon_names=info" />


</head>

<body>

  <script>

    // =======================================================
    // === 1. INICIALIZAÇÃO E CONFIGURAÇÃO DO FIREBASE ===
    // =======================================================

    const firebaseConfig = {
      apiKey: "AIzaSyDQwhYeLEvJW4p9Ml4pKjmr520CeKnZa60",
      authDomain: "coup-master.firebaseapp.com",
      databaseURL: "https://coup-master-default-rtdb.firebaseio.com",
      projectId: "coup-master",
      storageBucket: "coup-master.firebasestorage.app",
      messagingSenderId: "876117110623",
      appId: "1:876117110623:web:b957a148f9f60a51b550ea",
      measurementId: "G-2BQR65QP2Z"
    };

    // Inicializa o Firebase
    if (!firebaseConfig.apiKey) {
      document.body.innerHTML = "<h1>Erro: configure o firebaseConfig no script!</h1>";
      console.error("Firebase config is missing!");
    }

    firebase.initializeApp(firebaseConfig);
    const db = firebase.database();
    const gameStateRef = db.ref('gameState');


    // [NOVO] FUNÇÃO DE TOCAR SOM
    function playSound(id) {
      const sound = document.getElementById('audio-' + id);
      if (sound) {
        sound.currentTime = 0; // Reinicia o som se já estiver tocando (para cliques rápidos)
        sound.play().catch(e => console.log("Erro ao tocar som:", e));
      }
    }

    // [NOVO] Função para disparar som para TODOS via Firebase
    function triggerSound(soundId) {
        db.ref('gameState/lastSFX').set({
            id: soundId,
            timestamp: Date.now() // Usa o tempo para garantir que é um som novo
        });
    }

    // =======================================================
    // === 2. CONSTANTES E VARIÁVEIS GLOBAIS ===
    // =======================================================

    // [CORREÇÃO] Lista de TODAS as 10 cartas
    const CARD_TYPES = [
      { type: 'duque', color: '#f6b04d' },
      { type: 'capitao', color: '#ff3b3b' },
      { type: 'assassino', color: '#3aff7b' },
      { type: 'embaixador', color: '#49f0ff' },
      { type: 'condessa', color: '#ffb000' },
      { type: 'inquisidor', color: '#2a8cff' },
      // peronagens promo
      { type: 'benfeitor', color: '#C0C0C0' },
      { type: 'bufao', color: '#FF69B4' },
      { type: 'burgues', color: '#800080' },
      { type: 'burocrata', color: '#A52A2A' },
      // --- personagens originais ---
      { type: 'vigilante', color: '#FFFFFF' },
      { type: 'mercenario', color: '#FFFFFF' },
      { type: 'guardiao-real', color: '#FFFFFF' },
      { type: 'purificador', color: '#FFFFFF' },
      { type: 'tesoureiro_da_coroa', color: '#FFFFFF' },
      { type: 'diplomata', color: '#FFFFFF' },
      { type: 'marionetista', color: '#FFFFFF' },
      { type: 'contador_real', color: '#FFFFFF' },
      { type: 'contrabandista', color: '#FFFFFF' },
      { type: 'camaleao', color: '#FFFFFF' }
    ];

    // O estado local é um "espelho" do que está no Firebase
    let localGameState = {};
    let myPlayerId = null;
    let isDrawingCard = false; // Trava para cliques rápidos no deck]
    
    // [NOVO] Variável para rastrear o último som tocado e evitar repetições
    let lastSoundTimestamp = Date.now();

    // Referências do DOM
    const deckCountEl = document.getElementById('deck-count');
    const graveCountEl = document.getElementById('grave-count');
    const deckEl = document.getElementById('deck');
    const freeArea = document.getElementById('freeArea');
    const shuffleBtn = document.getElementById('shuffleBtn');
    const resetBtn = document.getElementById('resetBtn');

    // [NOVO] Referências do Asilo
    const asylumScoreEl = document.getElementById('asylum-score');
    const asylumPlusBtn = document.getElementById('asylum-plus');
    const asylumMinusBtn = document.getElementById('asylum-minus');

    function initializeGame() {
      // ... (código de session storage existente) ...

      if (!firebaseConfig.apiKey) return;

      gameStateRef.on('value', (snapshot) => {
        const state = snapshot.val();
        if (state) {
          
          // === [NOVO] Lógica de Sincronização de Som ===
          if (state.lastSFX && state.lastSFX.timestamp > lastSoundTimestamp) {
              lastSoundTimestamp = state.lastSFX.timestamp; // Atualiza o tempo
              playSound(state.lastSFX.id); // Toca o som localmente
          }
          // ============================================

          localGameState = state;
          renderAll();
        }
      });

      findAndOccupySlot();
      setupUI();
      setupDropzones();
      setupAutoScroll();
    }

    // =======================================================
    // === 3. FUNÇÕES DE CRIAÇÃO E MANIPULAÇÃO DO JOGO (LÓGICA) ===
    // =======================================================

    // [CORREÇÃO] createDeck agora lê a configuração passada
    function createDeck(config) { // <-- Aceita config
      let newDeck = [];
      let id = 1;

      if (!config) {
        console.error("Configuração do Deck (deckConfig) não encontrada! Usando padrão.");
        config = createDefaultDeckConfig();
      }

      // Loop pela config, não pelo CARD_TYPES
      for (const cardType in config) {
        const quantity = config[cardType];
        const cardInfo = CARD_TYPES.find(c => c.type === cardType); // Encontra a info da carta (cor)

        if (cardInfo && quantity > 0) {
          for (let i = 0; i < quantity; i++) {
            newDeck.push({
              id: 'c' + (id++),
              type: cardInfo.type,
              color: cardInfo.color,
              owner: null,
              visible: false,
              location: 'deck'
            });
          }
        }
      }

      shuffle(newDeck);
      return newDeck;
    }

    function shuffle(array) {
      for (let i = array.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [array[i], array[j]] = [array[j], array[i]];
      }
    }

    // Encontra uma carta dentro do objeto de estado do jogo
    function findCardById(state, id) {
      if (!state || !id) return null;
      let card = state.deck?.find(c => c.id === id);
      if (card) return card;
      card = state.freeCards?.find(c => c.id === id);
      if (card) return card;
      card = state.grave?.find(c => c.id === id);
      if (card) return card;

      for (let p = 1; p <= 8; p++) {
        card = state.players?.[p]?.hand?.find(c => c.id === id);
        if (card) return card;
      }
      return null;
    }

    // Remove uma carta de qualquer lugar em um objeto de estado
    function removeCardFromLocation(state, cardId) {
      if (!state || !cardId) return;
      if (state.deck) state.deck = state.deck.filter(c => c.id !== cardId);
      if (state.freeCards) state.freeCards = state.freeCards.filter(c => c.id !== cardId);
      if (state.grave) state.grave = state.grave.filter(c => c.id !== cardId);

      if (state.players) {
        for (let p = 1; p <= 8; p++) {
          if (state.players[p]?.hand) {
            state.players[p].hand = state.players[p].hand.filter(c => c.id !== cardId);
          }
        }
      }
    }

    // =======================================================
    // === 4. FUNÇÕES DE RENDERIZAÇÃO (ATUALIZAR A TELA) ===
    // =======================================================

    function clearDOM() {
      document.querySelectorAll('[data-hand]').forEach(h => h.innerHTML = '');
      freeArea.querySelectorAll('.card').forEach(n => n.remove());
      document.querySelectorAll('.slot').forEach(n => n.remove());
      document.querySelectorAll('.player-area.local-player')
        .forEach(el => el.classList.remove('local-player'));
      // Limpa o destaque de turno antes de redesenhar
      document.querySelectorAll('.player-area.active-turn')
        .forEach(el => el.classList.remove('active-turn'));
    }

    function createCardElement(card) {
      const el = document.createElement('div');
      el.className = 'card';
      el.draggable = true;
      el.dataset.cardId = card.id;

      if (shouldShowBack(card)) {
        el.classList.add('back');
      } else {
        const imageUrl = `./img/${card.type.toLowerCase()}.png`; // Ex: ./img/duque.png
        el.style.backgroundImage = `url('${imageUrl}')`;
      }

      el.addEventListener('dragstart', (ev) => {
        ev.dataTransfer.setData('text/plain', card.id);
      });

      el.addEventListener('dblclick', () => {
        returnCardToDeck(card.id);
      });

      return el;
    }

    function shouldShowBack(card) {
      if (card.location === 'deck') return true;
      if (card.location === 'free') return false;
      if (card.location?.startsWith('player-')) {
        return card.owner !== myPlayerId;
      }
      return false;
    }

    // A função de renderização principal
    function renderAll() {
      const state = localGameState;
      if (!state || !state.players) return;

      clearDOM();

      for (let pid = 1; pid <= 8; pid++) {

        const playerEl = document.getElementById(`player-${pid}`);
        if (!playerEl) continue;

        const player = state.players[pid] || { online: false, hand: [], score: 0, religion: 'catolico' };

        /* [REMOVIDO]
        if (state.turn === pid) {
            playerEl.classList.add('active-turn');
        }
        */

        // LÓGICA DE MOSTRAR/OCULTAR
        if (player.online) {
          playerEl.style.display = 'flex';
        } else {
          playerEl.style.display = 'none';
          continue;
        }

        const handContainer = document.querySelector(`#player-${pid} [data-hand]`);

        if (pid === myPlayerId) {
          playerEl.classList.add('local-player');
        }

        // [NOVO] Renderiza o status da Religião
        const religionEl = playerEl.querySelector('.religion-status');
        if (religionEl) {
          if (player.religion === 'protestante') {
            religionEl.textContent = 'Protestante';
            religionEl.classList.remove('catolico');
            religionEl.classList.add('protestante');
          } else {
            religionEl.textContent = 'Católico';
            religionEl.classList.remove('protestante');
            religionEl.classList.add('catolico');
          }
        }

        // 1. Renderiza os slots que TÊM cartas
        player.hand?.forEach((card) => {
          const slot = document.createElement('div');
          slot.className = 'slot small';

          const el = createCardElement(card);
          el.classList.add('small');

          slot.appendChild(el);
          handContainer.appendChild(slot);
        });

        // 2. Se a mão estiver vazia, mostra UM slot vazio
        if (!player.hand || player.hand.length === 0) {
          const slot = document.createElement('div');
          slot.className = 'slot small';
          handContainer.appendChild(slot);
        }

        // Atualiza pontuação
        const scoreEl = document.querySelector(`#player-${pid} .score`);
        scoreEl.textContent = player.score || 0;
      }

      // Renderiza cartas da área livre
      state.freeCards?.forEach(card => {
        const el = createCardElement(card);
        el.classList.add('small');
        freeArea.appendChild(el);
      });

      // Atualiza contadores
      deckCountEl.textContent = state.deck?.length || 0;
      if (graveCountEl) {
        graveCountEl.textContent = state.grave?.length || 0;
      }

      // [NOVO] Atualiza contador do Asilo
      if (asylumScoreEl) {
        asylumScoreEl.textContent = state.asylumScore || 0;
      }

      // [NOVO] Sincroniza a UI de Configuração do Deck
      if (state.deckConfig) {
        for (const cardType in state.deckConfig) {
          const input = document.getElementById(`config-${cardType}`);
          if (input) {
            input.value = state.deckConfig[cardType];
          }
        }
      }
    }

    // =======================================================
    // === 5. AÇÕES DO JOGADOR (ESCREVEM NO FIREBASE) ===
    // =======================================================

    // [CORREÇÃO] Função com trava de clique
    function drawCard() {
      if (!myPlayerId) return;

      if (isDrawingCard) {
        console.log("Aguarde, comprando carta...");
        return;
      }
      isDrawingCard = true;
      triggerSound('card-slide'); // <--- ADICIONE AQUI (Som de deslizar carta)

      gameStateRef.transaction((currentState) => {
        if (!currentState) {
          isDrawingCard = false; // [FIX] Libera a trava
          return;
        }

        if (!currentState.deck || currentState.deck.length === 0) {
          console.log("Deck vazio.");
          isDrawingCard = false; // [FIX] Libera a trava
          return;
        }

        const card = currentState.deck.pop();
        card.owner = myPlayerId;
        card.location = 'player-' + myPlayerId;
        card.visible = false;

        if (!currentState.players[myPlayerId].hand) {
          currentState.players[myPlayerId].hand = [];
        }
        currentState.players[myPlayerId].hand.push(card);

        return currentState;
      },
        (error, committed, snapshot) => {
          if (error) {
            console.error("Falha ao comprar carta:", error);
          }
          // Destrava a função, com sucesso ou falha
          isDrawingCard = false;
        });
    }


    function returnCardToDeck(cardId) {
      triggerSound('shuffle'); // <--- ADICIONE AQUI (Som de embaralhar/devolver)
      gameStateRef.transaction((currentState) => {
        if (!currentState) return currentState;

        const card = findCardById(currentState, cardId);
        if (!card) return currentState;

        removeCardFromLocation(currentState, cardId);

        card.owner = null;
        card.location = 'deck';
        card.visible = false;
        if (!currentState.deck) currentState.deck = [];
        currentState.deck.push(card);

        shuffle(currentState.deck);

        return currentState;
      });
    }

    function moveCard(cardId, targetLocation, targetPlayerId = null) {

      if (targetLocation === 'free') triggerSound('card-place'); // Som de colocar na mesa (cemitério)
      if (targetLocation === 'deck') triggerSound('shuffle');    // Som de devolver ao deck

      gameStateRef.transaction((currentState) => {
        if (!currentState) return currentState;

        const card = findCardById(currentState, cardId);
        if (!card) return currentState;

        if (targetLocation === 'player') {
          removeCardFromLocation(currentState, cardId);
          card.owner = targetPlayerId;
          card.location = 'player-' + targetPlayerId;
          card.visible = false;
          if (!currentState.players[targetPlayerId].hand) {
            currentState.players[targetPlayerId].hand = [];
          }
          currentState.players[targetPlayerId].hand.push(card);
        }
        else if (targetLocation === 'free') {
          removeCardFromLocation(currentState, cardId);
          card.owner = null;
          card.location = 'free';
          card.visible = true;
          if (!currentState.freeCards) currentState.freeCards = [];
          currentState.freeCards.push(card);
        }
        else if (targetLocation === 'deck') {
          removeCardFromLocation(currentState, cardId);
          card.owner = null;
          card.location = 'deck';
          card.visible = false;
          if (!currentState.deck) currentState.deck = [];
          currentState.deck.push(card);
          shuffle(currentState.deck);
        }

        return currentState;
      });
    }

    // [NOVA FUNÇÃO] KICK PLAYER
    function kickPlayer(pid) {
      if (!confirm(`Tem certeza que deseja remover o Jogador ${pid}?`)) {
        return;
      }

      // 1. Remove a persistência local (se for o próprio jogador)
      if (pid === myPlayerId) {
        sessionStorage.removeItem('myPlayerId'); // [CORREÇÃO] Usando sessionStorage
        myPlayerId = null; // Zera a ID local
        alert('Você foi removido da sala e seu slot está liberado.');
      }

      // 2. Atualiza o Firebase para 'online: false'
      db.ref(`gameState/players/${pid}`).update({
        online: false
      });
    }

    function updateScore(pid, amount) {
      triggerSound('coin'); // <--- ADICIONE AQUI
      const scoreRef = db.ref(`gameState/players/${pid}/score`);

      scoreRef.once('value', (snapshot) => {
        let newScore = (snapshot.val() || 0) + amount;
        if (newScore < 0) newScore = 0;
        scoreRef.set(newScore);
      });
    }

    // [NOVO] Função para o contador do Asilo
    function updateAsylumScore(amount) {
      triggerSound('coin'); // <--- ADICIONE AQUI

      const scoreRef = db.ref('gameState/asylumScore');
      scoreRef.once('value', (snapshot) => {
        let newScore = (snapshot.val() || 0) + amount;
        if (newScore < 0) newScore = 0;
        scoreRef.set(newScore);
      });
    }

    // [NOVO] Função para trocar religião
    function toggleReligion(pid) {
      triggerSound('paper'); // <--- ADICIONE AQUI
      const religionRef = db.ref(`gameState/players/${pid}/religion`);
      religionRef.transaction((currentReligion) => {
        return (currentReligion === 'catolico') ? 'protestante' : 'catolico';
      });
    }

    // [CORREÇÃO] resetTable agora aceita um argumento
    function resetTable(newConfig = null) {
      console.log("Resetando a mesa...");

      // Se uma nova config foi passada (pelo botão Aplicar), usa ela.
      // Se não (pelo botão Resetar), usa a que está salva.
      const configToUse = newConfig || localGameState.deckConfig || createDefaultDeckConfig();

      let newDeck = createDeck(configToUse); // <-- Passa a config para createDeck

      let currentPlayers = localGameState.players || {};

      let newPlayersState = {
        1: { online: currentPlayers[1]?.online || false, hand: [], score: 2, religion: 'catolico' },
        2: { online: currentPlayers[2]?.online || false, hand: [], score: 2, religion: 'protestante' },
        3: { online: currentPlayers[3]?.online || false, hand: [], score: 2, religion: 'catolico' },
        4: { online: currentPlayers[4]?.online || false, hand: [], score: 2, religion: 'protestante' },
        5: { online: currentPlayers[5]?.online || false, hand: [], score: 2, religion: 'catolico' },
        6: { online: currentPlayers[6]?.online || false, hand: [], score: 2, religion: 'protestante' },
        7: { online: currentPlayers[7]?.online || false, hand: [], score: 2, religion: 'catolico' },
        8: { online: currentPlayers[8]?.online || false, hand: [], score: 2, religion: 'protestante' },
      };

      let initialState = {
        deck: newDeck,
        grave: [],
        freeCards: [],
        asylumScore: 0, // [NOVO]
        deckConfig: configToUse, // Salva a config usada
        // turn: 1, // [REMOVIDO]
        players: newPlayersState
      };

      gameStateRef.set(initialState);
    }

    function shuffleDeck() {
      gameStateRef.transaction((currentState) => {
        if (currentState && currentState.deck) {
          shuffle(currentState.deck);
        }
        return currentState;
      });
    }

    // [FUNÇÃO NOVA]
    function createDefaultDeckConfig() {
      return {
        'duque': 5, 'capitao': 5, 'assassino': 5, 'embaixador': 5, 'condessa': 5,
        'inquisidor': 5, 'benfeitor': 0, 'bufao': 0, 'burgues': 0, 'burocrata': 0,

        'vigilante': 0, 'guardiao_real': 0, 'mercenario': 0, 'purificador': 0, 'tesoureiro_da_coroa': 0,
        'diplomata': 0, 'marionetista': 0, 'contador_real': 0, 'contrabandista': 0, 'camaleao': 0
      };
    }

    // =======================================================
    // === 6. SETUP DE EVENTOS E INICIALIZAÇÃO ===
    // =======================================================

    function setupDropzones() {
      deckEl.ondragover = ev => ev.preventDefault();
      deckEl.ondrop = ev => {
        ev.preventDefault();
        const id = ev.dataTransfer.getData('text/plain');
        moveCard(id, 'deck');
      };
      deckEl.onclick = () => drawCard();

      document.querySelectorAll('.player-area').forEach(area => {
        area.ondragover = ev => ev.preventDefault();
        area.ondrop = ev => {
          ev.preventDefault();
          const id = ev.dataTransfer.getData('text/plain');
          const pid = parseInt(area.dataset.player);
          moveCard(id, 'player', pid);
        };
      });

      freeArea.ondragover = ev => ev.preventDefault();
      freeArea.ondrop = ev => {
        ev.preventDefault();
        const id = ev.dataTransfer.getData('text/plain');
        moveCard(id, 'free');
      };
    }

    function setupUI() {
      // Botões de controle
      shuffleBtn.onclick = shuffleDeck;
      resetBtn.onclick = () => resetTable(); // Chama sem argumentos

      // === LÓGICA DA MÚSICA E VOLUME ===
      const musicBtn = document.getElementById('musicBtn');
      const bgmAudio = document.getElementById('bgmAudio');
      const volumeSlider = document.getElementById('volumeSlider');

      // Define o volume inicial
      if (bgmAudio) {
        bgmAudio.volume = 0.1; // 30%
      }

      // Lógica do Slider de Volume
      if (volumeSlider && bgmAudio) {
        // Sincroniza o slider com o volume inicial
        volumeSlider.value = bgmAudio.volume;

        volumeSlider.addEventListener('input', (e) => {
          const newVolume = e.target.value;
          bgmAudio.volume = newVolume;
        });
      }


      // Lógica do Botão Play/Pause
      if (musicBtn && bgmAudio) {

        // [MODIFICADO] Tenta tocar a música imediatamente ao carregar
        bgmAudio.play().then(() => {
          // Sucesso! O navegador permitiu. O botão fica normal (sem mute).
          musicBtn.classList.remove('muted');
        }).catch(error => {
          // Bloqueado! O navegador impediu o som automático.
          // Deixamos o botão mutado visualmente até o jogador clicar.
          console.log("Autoplay bloqueado (esperando interação):", error);
          musicBtn.classList.add('muted');
        });

        musicBtn.onclick = () => {
          if (bgmAudio.paused) {
            bgmAudio.play().then(() => {
              musicBtn.classList.remove('muted');
            }).catch(error => {
              console.log("Reprodução de áudio bloqueada:", error);
            });
          } else {
            bgmAudio.pause();
            musicBtn.classList.add('muted');
          }
        };
      }
      // === FIM DA LÓGICA DE MÚSICA ===


      // LÓGICA DO MODAL DE INFO
      const infoBtn = document.getElementById('infoBtn');
      const infoModal = document.getElementById('infoModal');
      const closeModalBtn = document.getElementById('closeModalBtn');
      const flipCard = document.querySelector('.flip-card'); // [NOVO] Referência à carta

      // Referências às imagens dentro do card
      const frontImg = flipCard ? flipCard.querySelector('.flip-card-front img') : null;
      const backImg = flipCard ? flipCard.querySelector('.flip-card-back img') : null;

      // Lista das 3 imagens (Ciclo: Base -> DLC -> Turno)
      // [IMPORTANTE]: Certifique-se de que 'dlc-actions.jpg' existe na pasta img!
      const ruleImages = [
        'img/front-actions.png', // 1. Ações Base (Início)
        'img/dlc-actions.png',   // 2. Ações DLC
        'img/back-actions.png'   // 3. Ações Turno
      ];

      // Controla qual imagem da lista estamos vendo atualmente (0, 1 ou 2)
      let currentRuleIndex = 0; 

      if (infoBtn && infoModal && closeModalBtn && flipCard) {
        
        // Ao abrir, reseta para o estado inicial
        infoBtn.onclick = () => {
          playSound('click');
          infoModal.style.display = 'flex';
          
          // Reseta tudo para a primeira imagem
          currentRuleIndex = 0;
          flipCard.classList.remove('is-flipped');
          frontImg.src = ruleImages[0];
          backImg.src = ruleImages[1]; // Já deixa a próxima preparada atrás
        };

        // Fechar Modal
        const closeModal = () => {
            playSound('click');
            infoModal.style.display = 'none';
        };
        closeModalBtn.onclick = closeModal;
        infoModal.onclick = (e) => {
          if (e.target === infoModal) closeModal();
        };

        // Lógica de Girar e Trocar Imagem (Ciclo Infinito)
        flipCard.onclick = () => {
            playSound('card-slide');
            
            // 1. Gira a carta
            flipCard.classList.toggle('is-flipped');
            
            // 2. Avança o índice para a próxima "página"
            currentRuleIndex = (currentRuleIndex + 1) % ruleImages.length;
            
            // 3. Prepara a imagem oculta para o próximo giro
            // Espera 200ms (metade do giro) para trocar a imagem de trás sem o usuário ver
            setTimeout(() => {
                const nextImageIndex = (currentRuleIndex + 1) % ruleImages.length;
                
                if (flipCard.classList.contains('is-flipped')) {
                    // Estamos vendo o Verso. Vamos mudar a Frente (que está escondida) para a próxima.
                    frontImg.src = ruleImages[nextImageIndex];
                } else {
                    // Estamos vendo a Frente. Vamos mudar o Verso (que está escondido) para a próxima.
                    backImg.src = ruleImages[nextImageIndex];
                }
            }, 500); // 500ms = metade do tempo da transição CSS (1s)
        };
      }

      // [NOVO] LÓGICA DO CONTADOR DO ASILO
      if (asylumPlusBtn && asylumMinusBtn) {
        asylumPlusBtn.onclick = () => updateAsylumScore(1);
        asylumMinusBtn.onclick = () => updateAsylumScore(-1);
      }

      // [NOVO] LÓGICA DO MODAL DE CONFIGURAÇÃO
      const configBtn = document.getElementById('configBtn');
      const configModal = document.getElementById('configModal');
      const closeConfigModalBtn = document.getElementById('closeConfigModalBtn');
      const applyDeckConfigBtn = document.getElementById('applyDeckConfigBtn');
      const configInputs = document.querySelectorAll('.card-config-item input');

      if (configBtn && configModal && closeConfigModalBtn) {

        playSound('click'); // <--- ADICIONE AQUI
        configBtn.onclick = () => { configModal.style.display = 'flex'; };

        playSound('click'); // <--- ADICIONE AQUI
        closeConfigModalBtn.onclick = () => { configModal.style.display = 'none'; };
      }

      // Lógica dos Inputs (apenas desabilitar)
      configInputs.forEach(input => {
        if (myPlayerId !== 1) {
          input.disabled = true;
        }
      });

      // [NOVA LÓGICA] Botão Aplicar
      if (applyDeckConfigBtn) {
        if (myPlayerId !== 1) {
          applyDeckConfigBtn.disabled = true;
          applyDeckConfigBtn.style.background = '#555';
          applyDeckConfigBtn.textContent = 'Apenas o Host (Jogador 1) pode aplicar';
        } else {
          applyDeckConfigBtn.onclick = () => {
            playSound('click'); // <--- ADICIONE AQUI
            // 1. Monta o objeto de configuração
            const newConfig = {};
            configInputs.forEach(input => {
              const cardType = input.dataset.card;
              let quantity = parseInt(input.value);
              if (isNaN(quantity) || quantity < 0) quantity = 0;
              if (quantity > 10) quantity = 10;
              input.value = quantity; // Corrige a UI
              newConfig[cardType] = quantity;
            });

            console.log("Aplicando nova configuração e resetando...", newConfig);

            // 2. Chama o reset passando a nova config
            resetTable(newConfig);

            // 3. Fecha o modal
            configModal.style.display = 'none';
          };
        }
      }


      // Controles de pontos +/- e NOVO BOTÃO DE REMOVER
      document.querySelectorAll('.player-area').forEach(area => {
        const pid = parseInt(area.dataset.player);

        // Listener para remover (kick) o jogador
        const removeBtn = area.querySelector('.remove-player');
        if (removeBtn) {
          removeBtn.addEventListener('click', () => {
            kickPlayer(pid);
          });
        }

        // [NOVO] Listener para trocar religião
        const religionEl = area.querySelector('.religion-status');
        if (religionEl) {
          religionEl.addEventListener('click', () => {
            toggleReligion(pid);
          });
        }

        // Listeners Plus/Minus
        area.querySelector('.plus').addEventListener('click', () => updateScore(pid, 1));
        area.querySelector('.minus').addEventListener('click', () => updateScore(pid, -1));
      });
    }

    // [CORREÇÃO] Usando sessionStorage para persistência por ABA
    // Lógica de "Entrar na Sala"
    function findAndOccupySlot() {
      const myPersistedId = sessionStorage.getItem('myPlayerId'); // <-- MUDADO para sessionStorage

      // Tenta re-ocupar o slot primeiro (Persistência)
      if (myPersistedId) {
        gameStateRef.transaction((currentState) => {
          if (!currentState || !currentState.players) return;

          const pid = parseInt(myPersistedId);

          if (currentState.players[pid] && !currentState.players[pid].online) {
            currentState.players[pid].online = true;
            myPlayerId = pid;
            return currentState;
          }

          sessionStorage.removeItem('myPlayerId'); // <-- MUDADO para sessionStorage
          return;
        }, (error, committed, snapshot) => {
          if (committed) {
            console.log(`Reclamei o slot persistido: Jogador ${myPlayerId}`);
            setupDisconnectHandler(myPlayerId);
            return;
          }
          findNewSlot();
        });
      } else {
        findNewSlot();
      }
    }

    // Função separada para lidar com a busca e o claim atômico
    function findNewSlot() {
      gameStateRef.transaction((currentState) => {
        if (!currentState || !currentState.players) {
          // Criação inicial da sala (JOGADOR 1)
          const defaultConfig = createDefaultDeckConfig(); // [NOVO]
          let newDeck = createDeck(defaultConfig); // [NOVO]

          let initialState = {
            deck: newDeck,
            grave: [],
            freeCards: [],
            asylumScore: 0, // [NOVO]
            deckConfig: defaultConfig, // [NOVO]
            // turn: 1, // [REMOVIDO]
            players: {
              1: { hand: [], score: 2, online: true, religion: 'catolico' },
              2: { hand: [], score: 2, online: false, religion: 'protestante' },
              3: { hand: [], score: 2, online: false, religion: 'catolico' },
              4: { hand: [], score: 2, online: false, religion: 'protestante' },
              5: { hand: [], score: 2, online: false, religion: 'catolico' },
              6: { hand: [], score: 2, online: false, religion: 'protestante' },
              7: { hand: [], score: 2, online: false, religion: 'catolico' },
              8: { hand: [], score: 2, online: false, religion: 'protestante' },
            }
          };
          myPlayerId = 1;
          sessionStorage.setItem('myPlayerId', 1); // <-- MUDADO para sessionStorage
          return initialState;
        }

        // Busca um slot vazio (online: false)
        for (let i = 1; i <= 8; i++) {
          if (!currentState.players[i] || !currentState.players[i].online) {
            // Ocupa o slot atomicamente
            currentState.players[i] = currentState.players[i] || {};
            currentState.players[i].online = true;
            currentState.players[i].score = currentState.players[i].score || 2;
            currentState.players[i].hand = currentState.players[i].hand || [];
            currentState.players[i].religion = (i % 2 === 1) ? 'catolico' : 'protestante';
            myPlayerId = i;
            sessionStorage.setItem('myPlayerId', i); // <-- MUDADO para sessionStorage
            return currentState;
          }
        }

        // Sala cheia, não pode entrar
        return;
      }, (error, committed, snapshot) => {
        if (committed) {
          console.log(`Entrei com sucesso: Jogador ${myPlayerId}`);
          setupDisconnectHandler(myPlayerId);
        } else if (error) {
          console.error("Erro na transação:", error);
          alert("Erro de conexão ao entrar na sala. Tente novamente.");
        } else {
          alert("Sala cheia! (Máx 8 jogadores)");
          document.body.innerHTML = "<h1>Sala cheia. Tente novamente mais tarde.</h1>";
        }
      });
    }

    // Handler para quando o jogador fechar a aba
    function setupDisconnectHandler(pid) {
      const playerRef = db.ref(`gameState/players/${pid}`);
      playerRef.onDisconnect().update({
        online: false
      });
    }


    // [NOVO] Função de Auto-Scroll para facilitar o drag-and-drop
    function setupAutoScroll() {
      const threshold = 80; // Pixels da borda para ativar o scroll
      const speed = 15;      // Velocidade de rolagem

      window.addEventListener('dragover', (e) => {
        // A posição Y do cursor/dedo
        const y = e.clientY;
        const viewportHeight = window.innerHeight;

        // Se estiver perto do topo -> Rola para cima
        if (y < threshold) {
          window.scrollBy(0, -speed);
        }
        // Se estiver perto do fundo -> Rola para baixo
        else if (y > (viewportHeight - threshold)) {
          window.scrollBy(0, speed);
        }
      });
    }

    // =======================================================
    // === 7. O "CORAÇÃO" DO JOGO (O Listener Principal) ===
    // =======================================================

    function initializeGame() {
      const persistedId = sessionStorage.getItem('myPlayerId');
      if (persistedId) {
        myPlayerId = parseInt(persistedId);
      }

      if (!firebaseConfig.apiKey) return;

      gameStateRef.on('value', (snapshot) => {
        const state = snapshot.val();
        if (state) {
          localGameState = state;
          renderAll();
        }
      });

      findAndOccupySlot();
      setupUI();
      setupDropzones();

      setupAutoScroll(); // <--- VOCÊ TINHA ESQUECIDO ESTA LINHA!
    }

    // Inicia o jogo!
    initializeGame();


  </script>
</body>

</html>